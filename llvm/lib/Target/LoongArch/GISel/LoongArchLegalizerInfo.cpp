//===-- LoongArchLegalizerInfo.cpp ------------------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the Machinelegalizer class for
/// LoongArch.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include "LoongArchLegalizerInfo.h"
#include "LoongArchSubtarget.h"
#include "llvm/CodeGen/TargetOpcodes.h"
#include "llvm/CodeGen/ValueTypes.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Type.h"

using namespace llvm;

LoongArchLegalizerInfo::LoongArchLegalizerInfo(const LoongArchSubtarget &ST)
    : STI(ST), GRLen(STI.getGRLen()), sGRLen(LLT::scalar(GRLen)) {
  const LLT p0 = LLT::pointer(0, GRLen);
  const LLT s8 = LLT::scalar(8);
  const LLT s16 = LLT::scalar(16);
  const LLT s32 = LLT::scalar(32);

  using namespace TargetOpcode;

  getActionDefinitionsBuilder({G_IMPLICIT_DEF, G_CONSTANT})
      .legalFor({sGRLen, p0})
      .widenScalarToNextPow2(0)
      .clampScalar(0, sGRLen, sGRLen);

  getActionDefinitionsBuilder(G_GLOBAL_VALUE).legalFor({p0});

  getActionDefinitionsBuilder({G_ANYEXT, G_SEXT, G_ZEXT}).maxScalar(0, sGRLen);

  getActionDefinitionsBuilder(G_SEXT_INREG)
      .legalFor({sGRLen})
      .maxScalar(0, sGRLen)
      .lower();

  for (unsigned Op : {G_MERGE_VALUES, G_UNMERGE_VALUES}) {
    unsigned BigTyIdx = Op == G_MERGE_VALUES ? 0 : 1;
    unsigned LitTyIdx = Op == G_MERGE_VALUES ? 1 : 0;
    getActionDefinitionsBuilder(Op)
        .widenScalarToNextPow2(LitTyIdx, GRLen)
        .widenScalarToNextPow2(BigTyIdx, GRLen)
        .clampScalar(LitTyIdx, sGRLen, sGRLen)
        .clampScalar(BigTyIdx, sGRLen, sGRLen);
  }

  getActionDefinitionsBuilder({G_ADD, G_SUB, G_AND, G_OR, G_XOR})
      .legalFor({sGRLen})
      .widenScalarToNextPow2(0)
      .clampScalar(0, sGRLen, sGRLen);

  getActionDefinitionsBuilder({G_SHL, G_LSHR, G_ASHR})
      .legalFor({{sGRLen, sGRLen}})
      .widenScalarToNextPow2(0)
      .clampScalar(1, sGRLen, sGRLen)
      .clampScalar(0, sGRLen, sGRLen);

  getActionDefinitionsBuilder(G_ICMP)
      .legalFor({{sGRLen, sGRLen}, {sGRLen, p0}})
      .widenScalarToNextPow2(1)
      .clampScalar(1, sGRLen, sGRLen)
      .clampScalar(0, sGRLen, sGRLen);

  getActionDefinitionsBuilder(G_SELECT)
      .legalFor({{sGRLen, sGRLen}, {p0, sGRLen}})
      .widenScalarToNextPow2(0)
      .clampScalar(0, sGRLen, sGRLen)
      .clampScalar(1, sGRLen, sGRLen);

  getActionDefinitionsBuilder(G_PTR_ADD).legalFor({{p0, sGRLen}});

  getActionDefinitionsBuilder({G_UADDO, G_USUBO, G_UADDE, G_USUBE}).lower();

  // Return the alignment needed for memory ops. If unaligned memory accesses
  // is allowed, we only require byte alignment. Otherwise, we need the memory
  // op to be natively aligned.
  auto getScalarMemAlign = [&ST](unsigned Size) {
    return ST.hasUAL() ? 8 : Size;
  };

  getActionDefinitionsBuilder({G_LOAD, G_STORE})
      .legalForTypesWithMemDesc({{sGRLen, p0, s8, getScalarMemAlign(8)},
                                 {sGRLen, p0, s16, getScalarMemAlign(16)},
                                 {sGRLen, p0, s32, getScalarMemAlign(32)},
                                 {sGRLen, p0, sGRLen, getScalarMemAlign(GRLen)},
                                 {p0, p0, sGRLen, getScalarMemAlign(GRLen)}})
      .clampScalar(0, sGRLen, sGRLen)
      .lower();

  auto &ExtLoadActions =
      getActionDefinitionsBuilder({G_SEXTLOAD, G_ZEXTLOAD})
          .legalForTypesWithMemDesc({{sGRLen, p0, s8, getScalarMemAlign(8)},
                                     {sGRLen, p0, s16, getScalarMemAlign(16)}});
  if (GRLen == 64)
    ExtLoadActions.legalForTypesWithMemDesc(
        {{sGRLen, p0, s32, getScalarMemAlign(32)}});
  ExtLoadActions.clampScalar(0, sGRLen, sGRLen).lower();

  getActionDefinitionsBuilder(G_PHI)
      .legalFor({p0, sGRLen})
      .widenScalarToNextPow2(0)
      .clampScalar(0, sGRLen, sGRLen);

  getActionDefinitionsBuilder(G_BRCOND).legalFor({sGRLen}).minScalar(0, sGRLen);

  getLegacyLegalizerInfo().computeTables();
}
